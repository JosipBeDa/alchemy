use crate::db::models::user;
use crate::db::repository::user::UserRepository;
use crate::error::Error;
use hextacy::{component, contract, Driver};

/*  An example of what would get generated by
 #[contract(
  use Driver as driver,
  use Users
)]
*/
pub struct UsersRepository<A, U>
where
    A: Driver,
{
    driver: A,
    _users: U,
}

impl<A, U> UsersRepository<A, U>
where
    A: Driver,
{
    pub fn new(driver: A, _users: U) -> Self {
        Self { driver, _users }
    }
}

// Example end

#[component(
    use Driver for Connection:Atomic,
    use UserRepository with Connection as User
)]
#[contract]
impl UsersRepository {
    async fn get_paginated(
        &self,
        page: u16,
        per_page: u16,
        sort: Option<user::SortOptions>,
    ) -> Result<Vec<user::User>, Error> {
        let mut conn = self.driver.connect().await?;
        User::get_paginated(&mut conn, page, per_page, sort)
            .await
            .map_err(Error::new)
    }
}

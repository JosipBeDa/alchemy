<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Core - Hextacy</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Quickstart.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="../Infrastructure/index.html"><strong aria-hidden="true">2.</strong> Infrastructure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Infrastructure/core.html" class="active"><strong aria-hidden="true">2.1.</strong> Core</a></li></ol></li><li class="chapter-item expanded "><a href="../Driver.html"><strong aria-hidden="true">3.</strong> Driver</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hextacy</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="core"><a class="header" href="#core">Core</a></h1>
<p>The next few sections of the booklet will provide some examples on how to model a decoupled application and how hextacy can be utilised to efficiently write application code while hiding away rust's unavoidable boilerplate.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Let's imagine we are tasked with creating an authentication service. For brevity's sake, we will keep the service very simple and we will not provide a <code>logout</code> method. After an intense brainstorming session we have determined the following:</p>
<p>The service must:</p>
<ul>
<li>
<p>expose 2 methods: <code>register</code> and <code>login</code>.</p>
</li>
<li>
<p>be able to work with 2 models (entities): <code>User</code> and <code>Session</code>.</p>
</li>
<li>
<p>notify any interested third parties that a user registered via a message broker.</p>
</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>For brevity, we will not be writing out the application plumbing (imports, errors, etc.) because we want to focus solely on the design. That said, full examples with plumbing can be viewed <a href="https://github.com/biblius/hextacy/tree/master/examples/">here</a>.</p>
<h3 id="models"><a class="header" href="#models">Models</a></h3>
<p>First things first, we have to define the application models:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct User {
    id: Uuid,
    username: String,
    password: String,
    created_at: NaiveDateTime, // from chrono
}

pub struct Session {
    id: Uuid,
    user_id: Uuid,
    created_at: NaiveDateTime,
    expires_at: NaiveDateTime,
}
<span class="boring">}</span></code></pre></pre>
<p>These models must be kept separate from ORM-specific entities. Any entity obtained from an ORM must be convertable to its respective application model. Here the <code>From</code> trait is our friend, but we will omit the implementation as it is straightforward.</p>
<h3 id="repository"><a class="header" href="#repository">Repository</a></h3>
<p>We now define a set of interactions with a persistence layer. You can think of repositories as contracts an adapter must fulfill for it to be injected into a service.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait UserRepository&lt;C&gt; {
    async fn get_by_username(
        &amp;self,
        conn: &amp;mut C,
        username: &amp;str,
    ) -&gt; Result&lt;Option&lt;User&gt;, AdapterError&gt;;

    async fn create(
        &amp;self,
        conn: &amp;mut C,
        username: &amp;str,
        password: &amp;str,
    ) -&gt; Result&lt;User, AdapterError&gt;;
}

#[async_trait]
pub trait SessionRepository&lt;C&gt; {
    async fn get_valid_by_id(
        &amp;self,
        conn: &amp;mut C,
        id: Uuid,
        csrf: Uuid,
    ) -&gt; Result&lt;Option&lt;Session&gt;, AdapterError&gt;;

    async fn create(
        &amp;self,
        conn: &amp;mut C,
        user: &amp;User,
        expires: bool,
    ) -&gt; Result&lt;Session, AdapterError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You might be wondering why the generic <code>C</code> bound. It will all become clear later, but for now you should just know that it enables us to easily perform transactions. We could theoretically design a repository with no generics, but it will introduce problems later down the line when we have the need for atomicity.</p>
<h3 id="service"><a class="header" href="#service">Service</a></h3>
<p>We now define the core authentication service struct. For the time being we will disregard the message broker requirement and focus solely on the first 2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Authentication&lt;D, UR, SR&gt; {
    driver: D,
    user_repo: UR,
    session_repo: SR,
}
<span class="boring">}</span></code></pre></pre>
<p>Since we do not know which adapters the service will be instantiated with, we must define it in terms of generics. Another option would be to define the <code>*_repo</code> fields using trait objects, i.e. <code>Box&lt;dyn UserRepository&lt;C&gt;&gt;</code>, but then we would have to introduce another generic for the connection, namely <code>C</code>, which arguably does not help us when we enter generics hell in the next step when defining the core functionality.</p>
<p>We now define the <code>login</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hextacy::Driver;

#[async_trait]
impl&lt;D, UR, SR&gt; Authentication&lt;D, UR, SR&gt;
where
  D: Driver + Send + Sync,
  D::Connection: Send,
  UR: UserRepository&lt;Driver::Connection&gt; + Send + Sync,
  SR: SessionRepository&lt;Driver::Connection&gt; + Send + Sync,
{
    async fn login(
        &amp;self,
        username: &amp;str,
        password: &amp;str,
        remember: bool,
    ) -&gt; AppResult&lt;ClientSession&gt; {
        let mut conn = self.repo.connect().await?;

        let user = match self.user_repo.get_by_username(&amp;mut conn, username).await {
            Ok(Some(user)) =&gt; user,
            Ok(None) =&gt; return Err(AuthenticationError::InvalidCredentials.into()),
            Err(e) =&gt; return Err(e.into()),
        };

        let hashed = hextacy::crypto::bcrypt_hash(password, 10)?;
        if hashed != password {
            return Err(AuthenticationError::InvalidCredentials.into());
        }

        let session = self
            .session_repo
            .create(&amp;mut conn, &amp;user, !remember)
            .await?;

        Ok(session.into())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>No wait, don't go, I promise it'll all make sense!</p>
<p>Our impl block is quite a mouthful so let's break it down.</p>
<p>In the impl block's definition, we introduced the necessary generics for the service and we've bound those generics to the traits we want the service to use.</p>
<p>We are essentially saying to the compiler &quot;<em>The authentication struct can use the <code>login</code> method if and only if its <code>driver</code> field implements <code>Driver</code> and its <code>*_repo</code> fields can work on the connection obtained from that driver</em>&quot;.</p>
<p>The <a href="../Driver.html">Driver</a> trait is a completely generic trait that exposes one method - <code>connect</code>. We need this trait because we've defined our repository to take in a generic <code>C</code> and now we can obtain that <code>C</code> from the driver. We still don't know which connection that will be - this is the whole point of the <code>Driver</code> trait and is how our service still remains oblivious to the adapter it will use.</p>
<p>Now, because the generics are bound to repositories we get access to the necessary repository methods and can get a hold of our application models. So far, no implementation details are exposed to the service. The only thing the service is aware of is that it can create some connection and use that connection for its repositories.</p>
<p>The real beauty of using a driver is in the next step, when we define our <code>register</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Same impl block as for the `login` method
async fn register(&amp;self, username: &amp;str, password: &amp;str) -&gt; AppResult&lt;ClientSession&gt; {
    let mut conn = self.repo.connect().await?;

    match self.user_repo.get_by_username(&amp;mut conn, username).await {
        Ok(None) =&gt; {}
        Ok(Some(_)) =&gt; return Err(AuthenticationError::UsernameTaken.into()),
        Err(e) =&gt; return Err(e.into()),
    };

    let hashed = hextacy::crypto::bcrypt_hash(password, 10)?;

    let user = self.user_repo.create(&amp;mut conn, username, &amp;hashed).await?;
    let session = self.session_repo.create(&amp;mut conn, &amp;user, true).await?;

    Ok(session.into())
}

<span class="boring">}</span></code></pre></pre>
<p>Ok, so you might be wondering where is this beauty we've mentioned - this just looks the same as the login method, big deal!</p>
<p>You would be completely right to wonder this and the above implementation does not in fact differ from the login method (other than the fact it executes different code). The beauty comes when we introduce database transactions.</p>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p>Imagine the above <code>session_repo.create</code> call failed and the function returned an error. A user would still be created, but they would receive no session and they wouldn't be granted application access.</p>
<p>This might not be a big deal for our simple auth service since the user could just login and continue on with their life, but imagine things are not so simple.</p>
<p>Imagine we have to execute multiple state changes to multiple repositories. If you've ever had problems with this in the real world, you already know that having incomplete state/partial updates in a database is when being a vegetable farmer doesn't start to look all that bad.</p>
<p>Luckily, smarter people than we have thought about this and they have provided us with a simple, yet effective tool to mitigate this problem - transactions! If you don't know what those are, they are essentially the database equivalent of all or nothing.</p>
<p>In order to get transactional integrity for our queries, we must devise a way for our driver, specifically its connection, to
perform atomic queries. Most connections/db clients provide this out of the box with 3 simple methods:</p>
<ul>
<li><code>start_transaction</code></li>
<li><code>commit_transaction</code></li>
<li><code>rollback_transaction</code></li>
</ul>
<p>For this purpose, hextacy provides this functionality on any generic connection via the <a href="../Driver.html#Atomic">Atomic</a> trait.
Because transactions usually operate on the same connections, i.e. queries on a connection that started a transaction will all be executed within that transaction's context, we get the answer to the age old question of &quot;Why put the <code>C</code> in the repository?&quot;.</p>
<p>If our repository methods did not take in a <code>C</code>, then we would not be able to pass a transaction through multiple repository calls.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Infrastructure/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Driver.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Infrastructure/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Driver.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

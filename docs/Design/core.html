<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Core - Hextacy</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Quickstart.html"><strong aria-hidden="true">1.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="../Design/index.html"><strong aria-hidden="true">2.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Design/core.html" class="active"><strong aria-hidden="true">2.1.</strong> Core</a></li><li class="chapter-item expanded "><a href="../Design/core-6tc.html"><strong aria-hidden="true">2.2.</strong> Core â¬¡</a></li><li class="chapter-item expanded "><a href="../Design/infrastructure.html"><strong aria-hidden="true">2.3.</strong> Infrastructure</a></li><li class="chapter-item expanded "><a href="../Design/state.html"><strong aria-hidden="true">2.4.</strong> State</a></li><li class="chapter-item expanded "><a href="../Design/testing.html"><strong aria-hidden="true">2.5.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="../Driver.html"><strong aria-hidden="true">3.</strong> Driver</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hextacy</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="core"><a class="header" href="#core">Core</a></h1>
<p>The next few sections of the booklet will provide some examples on how to model a decoupled application and how hextacy can be utilised to efficiently write application code while hiding away rust's unavoidable boilerplate.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Let's imagine we are tasked with creating an authentication service. We choose an auth service because it is simple enough for everyone to understand while still being able to highlight the importance of a layered architecture. For brevity's sake, we will keep the service very simple and we will not provide a <code>logout</code> method for user retention. After an intense brainstorming session we have determined the following:</p>
<p>The service must:</p>
<ul>
<li>
<p>expose 2 methods: <code>register</code> and <code>login</code>.</p>
</li>
<li>
<p>be able to work with 2 models (entities): <code>User</code> and <code>Session</code>.</p>
</li>
<li>
<p>notify any interested third parties a user registered via a message broker.</p>
</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>For brevity, we will not be writing out the application plumbing (imports, errors, etc.) because we want to focus solely on the design. Full examples with plumbing can be viewed <a href="https://github.com/biblius/hextacy/tree/master/examples/">in the examples directory</a>.</p>
<h3 id="models-entities"><a class="header" href="#models-entities">Models (Entities)</a></h3>
<p>First things first, we have to define the application models:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct User {
    id: Uuid,
    username: String,
    password: String,
    created_at: NaiveDateTime, // from chrono
}

pub struct Session {
    id: Uuid,
    user_id: Uuid,
    created_at: NaiveDateTime,
    expires_at: NaiveDateTime,
}
<span class="boring">}</span></code></pre></pre>
<p>These models must be kept separate from ORM-specific entities. Any entity obtained from an ORM must be convertable to its respective application model. Here the <code>From</code> trait is our friend, but we will omit the implementation as it is straightforward.</p>
<p><em>ORM entities are distinct (and confusingly named the same way) from our application entities, which from now on we will refer to as application models. An entity is a concept from domain driven design representing a data structure with semantic meaning to our application. Since we are dealing with authentication, the <code>User</code> and <code>Session</code> structs are the application entities as they represent core concepts from the real world. Each entity (application model) must be uniquely identifiable - as such, the ID generation for those entities must be in the hands of our app, rather than the underlying persistence implementation.</em></p>
<h3 id="repository"><a class="header" href="#repository">Repository</a></h3>
<p>We now define a set of interactions with a persistence layer. You can think of repositories as contracts an adapter must fulfill for it to be injected into a service.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait UserRepository&lt;C&gt; {
    async fn get_by_username(
        &amp;self,
        conn: &amp;mut C,
        username: &amp;str,
    ) -&gt; Result&lt;Option&lt;User&gt;, AdapterError&gt;;

    async fn create(
        &amp;self,
        conn: &amp;mut C,
        username: &amp;str,
        password: &amp;str,
    ) -&gt; Result&lt;User, AdapterError&gt;;
}

#[async_trait]
pub trait SessionRepository&lt;C&gt; {
    async fn get_valid_by_id(
        &amp;self,
        conn: &amp;mut C,
        id: Uuid,
    ) -&gt; Result&lt;Option&lt;Session&gt;, AdapterError&gt;;

    async fn create(
        &amp;self,
        conn: &amp;mut C,
        user: &amp;User,
        expires: bool,
    ) -&gt; Result&lt;Session, AdapterError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>The service will now be able utilise these definitions and in doing so won't be coupled to any particular implementation. If you're wondering why the <code>C</code>, we could theoretically design a repository with no generics, but it will introduce problems later down the line when we stray off the happy path.</p>
<h3 id="service"><a class="header" href="#service">Service</a></h3>
<p>We now define the core authentication service struct. For the time being we will disregard the message broker requirement and focus solely on the first 2.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Authentication&lt;D, UR, SR&gt; {
    driver: D,
    user_repo: UR,
    session_repo: SR,
}
<span class="boring">}</span></code></pre></pre>
<p>Since we do not know which adapters the service will be instantiated with, we must define it in terms of generics. Another option would be to define the <code>*_repo</code> fields using trait objects, i.e. <code>Box&lt;dyn UserRepository&lt;C&gt;&gt;</code>, but then we would have to introduce another generic for the connection, namely <code>C</code>, which arguably does not help us when we enter generics hell in the next step when defining the core functionality.</p>
<p>We now define the <code>login</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hextacy::Driver;

#[async_trait]
impl&lt;D, UR, SR&gt; Authentication&lt;D, UR, SR&gt;
where
  D: Driver + Send + Sync,
  D::Connection: Send,
  UR: UserRepository&lt;Driver::Connection&gt; + Send + Sync,
  SR: SessionRepository&lt;Driver::Connection&gt; + Send + Sync,
{
    async fn login(
        &amp;self,
        username: &amp;str,
        password: &amp;str,
        remember: bool,
    ) -&gt; AppResult&lt;Session&gt; {
        let mut conn = self.repo.connect().await?;

        let user = match self.user_repo.get_by_username(&amp;mut conn, username).await {
            Ok(Some(user)) =&gt; user,
            Ok(None) =&gt; return Err(AuthenticationError::InvalidCredentials.into()),
            Err(e) =&gt; return Err(e.into()),
        };

        let valid = hextacy::crypto::bcrypt_verify(password, &amp;user.password)?;
        if !valid {
            return Err(AuthenticationError::InvalidCredentials.into());
        }

        let session = self
            .session_repo
            .create(&amp;mut conn, &amp;user, !remember)
            .await?;

        Ok(session)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>In the first circle of generics hell we can observe the famous Send and Sync bounds from the async rust habitat...</em></p>
<p>In the impl block's definition, we introduced the necessary generics for the service and we've bound those generics to the traits we want the service to use. We are essentially saying to the compiler &quot;<em>The authentication struct can use the <code>login</code> method if and only if its <code>driver</code> field implements <code>Driver</code> and its <code>*_repo</code> fields can work on the connection obtained from that driver</em>&quot;.</p>
<p>The <a href="../Driver.html">Driver</a> trait is a completely generic trait that exposes one method - <code>connect</code>. It is literally just</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait Driver {
    type Connection;
    async fn connect(&amp;self) -&gt; Result&lt;Self::Connection, DriverError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>We need this trait because we've defined our repository to take in a generic <code>C</code> and now we can obtain that <code>C</code> from the driver. We still don't know which connection that will be - this is the whole point of the <code>Driver</code> trait and is how our service still remains oblivious to the adapter it will use.</p>
<p>Because the generics are bound to repositories we get access to the necessary repository methods and can get a hold of our application models. So far, no implementation details are exposed to the service. The only thing the service is aware of is that it can create some connection and use that connection for its repositories.</p>
<p>The real beauty of using a driver is in the next step, when we define our <code>register</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Same impl block as for the `login` method
async fn register(&amp;self, username: &amp;str, password: &amp;str) -&gt; AppResult&lt;Session&gt; {
    let mut conn = self.driver.connect().await?;

    match self.user_repo.get_by_username(&amp;mut conn, username).await {
        Ok(None) =&gt; {}
        Ok(Some(_)) =&gt; return Err(AuthenticationError::UsernameTaken.into()),
        Err(e) =&gt; return Err(e.into()),
    };

    let hashed = hextacy::crypto::bcrypt_hash(password, 10)?;

    let user = self.user_repo.create(&amp;mut conn, username, &amp;hashed).await?;
    let session = self.session_repo.create(&amp;mut conn, &amp;user, true).await?;

    Ok(session)
}

<span class="boring">}</span></code></pre></pre>
<p><em>...but this just looks like the login method, what's up?</em></p>
<p>We now stray from the happy path.</p>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p>Imagine the above <code>session_repo.create</code> call failed and the function returned an error. A user would still be created, but they would receive no session and they wouldn't be granted application access.
This might not be a big deal for our simple auth service since the user could just login and continue on with their life, but imagine things are not so simple.</p>
<p>Imagine we have to execute multiple state changes to multiple repositories. When there are multiple pending state changes, we want to persist those changes only if all of them succeed, and conversely we want to revert all changes if any of them fail. For this we need transactions. In order to use transactions, we must devise a way for our driver, specifically its connection, to allow us to perform atomic queries with it. Most connections/db clients provide this out of the box with 3 simple methods:</p>
<ul>
<li><code>start_transaction</code></li>
<li><code>commit_transaction</code></li>
<li><code>rollback_transaction</code></li>
</ul>
<p>For this purpose, hextacy provides this functionality on any generic connection via the <a href="../Driver.html#Atomic">Atomic</a> trait.
Because transactions usually operate on the same connections, i.e. queries on a connection that started a transaction will all be executed within that transaction's context, we get the answer to the age old question of &quot;Why put the <code>C</code> in the repository?&quot;.</p>
<p>If our repository methods did not take in a <code>C</code>, then we would not be able to pass a transaction through multiple repository calls.</p>
<p>We now update the register method to support transactions and isolate the creation of users and sessions to a neat little function. <code>//</code> marks lines added/changed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use hextacy::{Atomic, Driver};

#[async_trait]
impl&lt;D, UR, SR&gt; Authentication&lt;D, UR, SR&gt;
where
  D: Driver + Send + Sync,
  D::Connection: Atomic + Send, //
  UR:
    UserRepository&lt;D::Connection&gt; +
    UserRepository&lt;&lt;D::Connection as Atomic&gt;::TransactionResult&gt; + //
    Send +
    Sync,
  SR:
    SessionRepository&lt;D::Connection&gt; +
    SessionRepository&lt;&lt;D::Connection as Atomic&gt;::TransactionResult&gt; + //
    Send +
    Sync,
{
    pub async fn register(&amp;self, username: &amp;str, password: &amp;str) -&gt; AppResult&lt;Session&gt; {
        let mut conn = self.driver.connect().await?;

        match self.user_repo.get_by_username(&amp;mut conn, username).await {
            Ok(None) =&gt; {}
            Ok(Some(_)) =&gt; return Err(AuthenticationError::UsernameTaken.into()),
            Err(e) =&gt; return Err(e.into()),
        };

        let hashed = hextacy::crypto::bcrypt_hash(password, 10)?;

        let mut tx = conn.start_transaction().await?;
        match self //
            .create_user_and_session(&amp;mut tx, username, &amp;hashed)
            .await
        {
            Ok(session) =&gt; {
                &lt;Repo::Connection as Atomic&gt;::commit_transaction(tx).await?;
                Ok(session)
            }
            Err(e) =&gt; {
                &lt;Repo::Connection as Atomic&gt;::abort_transaction(tx).await?;
                Err(e)
            }
        }
    }

    pub async fn create_user_and_session( //
        &amp;self,
        tx: &amp;mut &lt;Repo::Connection as Atomic&gt;::TransactionResult,
        username: &amp;str,
        password: &amp;str,
    ) -&gt; AppResult&lt;Session&gt; {
        let user = self.user_repo.create(tx, username, password).await?;
        let session = self.session_repo.create(tx, &amp;user, true).await?;
        Ok(session)
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>...and in the 9th circle of generics hell we can observe the impenetrable wall of ultimate bounds</em></p>
<p>I know, I know - who in their right mind would want to write all of this out? Our service has only 2 repositories and already half of our file is noisy generics. While we are reaping the benefit of having atomic queries we've stumbled upon another problem - boilerplate. We'll figure that one out in the next section, but first let's focus on how the code differs from our original implementation.</p>
<p>Now, before we start with the state changes in our database we start a transaction. This is possible because we've bound the driver's connection to <code>Atomic</code>. When we get the results of <code>create_user_and_session</code>, we make sure to perform the necessary action on the transaction, ensuring the changes are only committed if everything was successful. This is where rust absolutely shines because we have total control on each of our interactions.</p>
<p>One other thing to note for this approach is encapsulation. Since now the service is responsible for obtaining connections, one could argue that the driver does not belong in the service implementation logic since it is doing what is supposedly the repository's job. Repositories can be designed with no generics, as stated previously, and this would allow the service to completely remove the driver from its definition. This is a completely valid decision if one does not need atomicity in their queries and makes defining services with <code>Box&lt;dyn Repository&gt;</code> a great option. On the other hand, when we need transactions, the service always has the necessary context to reason about whether or not a transaction should succeed and should be left up to the service, in which case the <code>C</code> is unavoidable.</p>
<p>In the next section we'll tear down the wall of generics and streamline the process of writing services using hextacy.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Design/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Design/core-6tc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Design/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Design/core-6tc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
